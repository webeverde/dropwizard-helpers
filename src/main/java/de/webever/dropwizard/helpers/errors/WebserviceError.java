package de.webever.dropwizard.helpers.errors;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import javax.validation.ConstraintViolation;
import javax.validation.Path.Node;
import javax.validation.metadata.ConstraintDescriptor;

/**
 * An object to wrap error information for the frontend. Converts Dropwizard
 * {@link ConstraintViolation}s and adds some semantics.
 * 
 * @author Richard Naeve
 *
 */
public class WebserviceError implements Comparable<WebserviceError> {

    /**
     * A bunch of standard errors for your convenience.
     * 
     * @author Richard Naeve
     *
     */
    public static enum FIXED {
    UNKNOWN(new WebserviceError(0, "Unknown: %s")),
    NOT_FOUND(new WebserviceError(1, 404, "not found")),
    FORBIDDEN(new WebserviceError(2, 403, "forbidden")),
    BAD_REQUEST(new WebserviceError(3, "bad request")),
    INTERNAL_ERROR(new WebserviceError(5, 500, "internal error")),
    SESSION_INVALID(new WebserviceError(100, 403, "No session for session id found")),
    REQUIRED(new WebserviceError(200, "Value is required")),
    INVALID_FORMAT(new WebserviceError(201, "Format is invalid. Expected format %s")),
    VALUE_TO_LOW(new WebserviceError(202, "Value too low. Min value is %s")),
    VALUE_TO_HIGH(new WebserviceError(203, "Value too high. Max value is %s")),
    VALUE_WRONG_LENGTH(new WebserviceError(204, "Value has wrong length. Length is between %s and %s")),
    VALUE_TOO_LONG(new WebserviceError(205, "Value it too long. Length should not exeed %s")),
    VALUE_TOO_SHORT(new WebserviceError(206, "Value it too short. Length should be greater than %s")),
    DUPLICATE(new WebserviceError(210, "Value already exists and must be unique.")),
    UNMET_DEPENDENCY(new WebserviceError(211, "Dependency could not be resolved.")),
    CONSTRAINT_VIOLATION(new WebserviceError(212, "A constraint was violated by this action. %s"));

	private final WebserviceError error;

	private FIXED(WebserviceError error) {
	    this.error = error;
	}

	public WebserviceError getError() {
	    return error;
	}

	public WebserviceErrorContainer getContainer(String field, Object... args) {
	    return getError().getContainer(field, args);
	}

	public WebserviceErrorContainer getContainer(String field, HashMap<String, String> data, Object... args) {
	    return getError().getContainerWithData(field, data, args);
	}

    }

    private int code;
    private int status;
    private String description;

    public WebserviceError(int code, String description) {
	this(code, 400, description);
    }

    public WebserviceError(int code, int status, String description) {
	this.code = code;
	this.status = status;
	this.description = description;
    }

    public int getStatus() {
	return status;
    }

    public int getCode() {
	return code;
    }

    /**
     * @return the description
     */
    public String getDescription() {
	return description;
    }

    public String getDescription(Object... args) {
	return String.format(description, args);
    }

    public WebserviceErrorContainer getContainer(String field, Object... args) {
	return new WebserviceErrorContainer(field, this, args);
    }

    public WebserviceErrorContainer getContainerWithData(String field, HashMap<String, String> data, Object... args) {
	return new WebserviceErrorContainer(field, this, data, args);
    }

    /**
     * Create a WebserviceErrorContainer with more semantic information from a
     * {@link ConstraintViolation}
     * 
     * @param constraintViolation
     *            the violation generated by DropWizard.
     * @return the error.
     */
    public static WebserviceErrorContainer forValidation(ConstraintViolation<?> constraintViolation) {
	String field = "unknown";
	Iterator<Node> it = constraintViolation.getPropertyPath().iterator();
	ArrayList<String> pathComponents = new ArrayList<>();
	while (it.hasNext()) {
	    pathComponents.add(it.next().getName());
	}
	// Validation error directly on a parameter
	if (pathComponents.size() == 2) {
	    String[] ar = pathComponents.get(1).split(" ");
	    field = ar[ar.length - 1];
	} else if (pathComponents.size() > 2) {
	    // Validation error nested in object in body
	    field = "body";
	    for (int i = 2; i < pathComponents.size(); i++) {
		field += "." + pathComponents.get(i);
	    }
	} else if (pathComponents.size() == 1) {
	    field = "body." + pathComponents.get(0);
	}
	ConstraintDescriptor<?> descriptor = constraintViolation.getConstraintDescriptor();
	String validation = descriptor.getAnnotation().annotationType().getSimpleName();
	switch (validation) {
	case "ValidationMethod":
	    String message = constraintViolation.getMessage();
	    String[] ar = message.split(":");
	    int c = 0;
	    if (ar.length == 2) {
		try {
		    c = Integer.valueOf(ar[0]);
		} catch (Exception e) {
		}
		message = ar[1];
	    }
	    return new WebserviceError(c, message).getContainer(field);
	case "NotNull":
	case "NotEmpty":
	    return FIXED.REQUIRED.getContainer(field);
	case "Pattern":
	    return FIXED.INVALID_FORMAT.getContainer(field, descriptor.getAttributes().get("regexp"));
	case "Email":
	    return FIXED.INVALID_FORMAT.getContainer(field, "email");
	case "Max":
	    return FIXED.VALUE_TO_HIGH.getContainer(field, descriptor.getAttributes().get("value"));
	case "Min":
	    return FIXED.VALUE_TO_LOW.getContainer(field, descriptor.getAttributes().get("value"));
	case "Size":
	case "Length":
	    return FIXED.VALUE_WRONG_LENGTH.getContainer(field, descriptor.getAttributes().get("min"),
		    descriptor.getAttributes().get("max"));
	}

	Object[] args = new Object[1];
	args[0] = validation;
	return FIXED.UNKNOWN.getContainer(field, args);
    }

    @Override
    public int compareTo(WebserviceError o) {
	return code - o.code;
    }

}
