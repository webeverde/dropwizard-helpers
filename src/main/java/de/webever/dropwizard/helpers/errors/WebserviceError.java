package de.webever.dropwizard.helpers.errors;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.Iterator;

import javax.validation.ConstraintViolation;
import javax.validation.Path.Node;
import javax.validation.metadata.ConstraintDescriptor;
import javax.ws.rs.FormParam;
import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;

/**
 * An object to wrap error information for the frontend. Converts Dropwizard
 * {@link ConstraintViolation}s and adds some semantics.
 * 
 * @author Richard Naeve
 *
 */
public class WebserviceError {

    public static enum FIXED {
	UNKNOWN(new WebserviceError(0, "Unknown: %s")),
	SESSION_INVALID(new WebserviceError(100, 403, "No session for session id found")),
	REQUIRED(new WebserviceError(200, "Value is required")),
	INVALID_FORMAT(new WebserviceError(201, "Format is invalid. Expected format %s")),
	VALUE_TO_LOW(new WebserviceError(202, "Value too low. Min value is %s")),
	VALUE_TO_HIGH(new WebserviceError(203, "Value too high. Max value is %s")),
	VALUE_WRONG_LENGTH(new WebserviceError(204, "Value has wrong length. Length is between %s and %s")),
	VALUE_TOO_LONG(new WebserviceError(205, "Value it too long. Length should not exeed %s")),
	VALUE_TOO_SHORT(new WebserviceError(206, "Value it too short. Length should be greater than %s")),
	DUPLICATE(new WebserviceError(210, "Value already exists and must be unique.")), 
	UNMET_DEPENDENCY(new WebserviceError(211, "Dependency could not be resolved.")),;

	private final WebserviceError error;

	private FIXED(WebserviceError error) {
	    this.error = error;
	}

	public WebserviceError getError() {
	    return error;
	}

	public WebserviceErrorContainer getContainer(String field, Object... args) {
	    return getError().getContainer(field, args);
	}

    }

    private int code;
    private int status;
    private String description;

    public WebserviceError(int code, String description) {
	this(code, 400, description);
    }

    public WebserviceError(int code, int status, String description) {
	this.code = code;
	this.status = status;
	this.description = description;
    }

    public int getStatus() {
	return status;
    }

    public int getCode() {
	return code;
    }

    public String getDescription(Object... args) {
	return String.format(description, args);
    }

    public WebserviceErrorContainer getContainer(String field, Object... args) {
	return new WebserviceErrorContainer(field, this, args);
    }

    /**
     * Create a WebserviceErrorContainer with more semantic information from a
     * {@link ConstraintViolation}
     * 
     * @param constraintViolation
     *            the violation generated by DropWizard.
     * @return the error.
     */
    public static WebserviceErrorContainer forValidation(ConstraintViolation<?> constraintViolation) {
	String field = "unknown";
	Iterator<Node> it = constraintViolation.getPropertyPath().iterator();
	ArrayList<String> pathComponents = new ArrayList<>();
	while (it.hasNext()) {
	    pathComponents.add(it.next().getName());
	}
	// Validation error directly on a parameter
	if (pathComponents.size() == 2) {

	    try {
		String path0 = pathComponents.get(0);
		Integer paramIndex = Integer.parseInt(pathComponents.get(1).substring(3));
		Method method = null;
		// find method and get value of annotation
		for (Method m : constraintViolation.getRootBeanClass().getMethods()) {
		    if (m.getName().equals(path0)) {
			method = m;
			break;
		    }
		}
		if (method != null) {
		    Parameter p = method.getParameters()[paramIndex];
		    Annotation[] list = p.getAnnotations();
		    for (Annotation annotation : list) {
			if (annotation.annotationType().equals(FormParam.class)) {
			    field = ((FormParam) annotation).value();
			} else if (annotation.annotationType().equals(QueryParam.class)) {
			    field = ((QueryParam) annotation).value();
			} else if (annotation.annotationType().equals(PathParam.class)) {
			    field = ((PathParam) annotation).value();
			}
		    }
		}
	    } catch (SecurityException e) {
	    }
	} else if (pathComponents.size() > 2) {
	    // Validation error nested in object in body
	    field = "body";
	    for (int i = 2; i < pathComponents.size(); i++) {
		field += "." + pathComponents.get(i);
	    }
	} else if (pathComponents.size() == 1) {
	    field = "body." + pathComponents.get(0);
	}
	ConstraintDescriptor<?> descriptor = constraintViolation.getConstraintDescriptor();
	String validation = descriptor.getAnnotation().annotationType().getSimpleName();
	switch (validation) {
	case "NotNull":
	    return FIXED.REQUIRED.getContainer(field);
	case "Pattern":
	    return FIXED.INVALID_FORMAT.getContainer(field, descriptor.getAttributes().get("regexp"));
	case "Max":
	    return FIXED.VALUE_TO_HIGH.getContainer(field, descriptor.getAttributes().get("value"));
	case "Min":
	    return FIXED.VALUE_TO_LOW.getContainer(field, descriptor.getAttributes().get("value"));
	case "Size":
	    return FIXED.VALUE_WRONG_LENGTH.getContainer(field, descriptor.getAttributes().get("min"), descriptor.getAttributes().get("max"));
	}

	Object[] args = new Object[1];
	args[0] = validation;
	return FIXED.UNKNOWN.getContainer(field, args);
    }

}
